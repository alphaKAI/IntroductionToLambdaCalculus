\chapter{ラムダ計算の概要}{
	\section{ラムダ計算とは}{
		ラムダ計算とは、計算模型(計算モデル)の一つであり、計算の実行を{\bf 関数への引数の評価(evaluation)と適用(application)としてモデル化・抽象化した計算体系}である。
		ラムダ算法と呼ばれることもある。また、ラムダ計算という名前は、関数を抽象化して表現する式にλ(ラムダ)を用いるという慣例に由来する。
		また、ラムダ計算には「型なしラムダ計算」と「型付きラムダ計算」という2つの体系が存在するが、本書では基本的に明示しないかぎり、「ラムダ計算」は「型付きラムダ計算」を意味するものとする。「型付きラムダ計算」についての本書の扱いについては1章に書いたのでそちらを参照してもらいたい。\\
		\\
		ラムダ計算は{\bf 「1つの変換規則(変数置換)と、1つの関数定義の規則のみをもつ、最小の(ユニバーサルな)プログラミング言語」}として捉えることもできる。ここでの「ユニバーサルな」とは、すべての計算可能な関数\footnote{計算可能性については後に説明する}が表現でき、正しく評価されるという意味である。これは、ラムダ計算がチューリングマシンと等価な数理モデルであることを意味している。ラムダ計算がチューリングマシンと等価な数理モデルであることは、「ラムダ計算はチューリング完全である」\footnote{チューリング完全は、チューリングコンプリートとも言う}と言い換えることができる。\\
		なお、チューリングマシンとチューリング完全についてはこの部の末章で説明する. \\
		\\
		ラムダ計算がチューリングマシンと等価な数理モデルであることは後に説明する不動点コンビネータを用いることで、ラムダ計算の範囲内で関数の再帰\footnote{再帰とは、ある関数$f$がその関数のなかで、自分自身、すなわち関数$f$を呼び出すことである}が可能になる。、これがループと等価な効果をもたらす。\\
		ただし、再帰によるループの実現を汎用的なプログラミング言語を用いて実装する場合には注意すべきことが存在する。それはチューリングマシンがループを行う場合、無限回(または膨大な回数)のループが発生してもループが原因で処理不可能ということは起こらない。しかし、再帰の場合、関数を呼び出すと関数のローカル変数(引数や局所変数)や戻り先情報を保持するスタックフレームが生成されコールスタックと呼ばれるスタックにpushされていく。従って、その回数が大きくなるとスタックオーバーフローを起こしてしまう可能性があり、再帰には限界がある。従って、それを避けるために再帰は末尾再帰にすべきである。
	}
	%歴史
	%	ラムダ計算は{\bf アロンゾ・チャーチ}\footnote{アメリカの論理学者, 数学者。ラムダ計算の創始者}と{\bf スティーヴン・コール・クリーネ}\footnote{アメリカの数学者。}
}

\chapter{チューリングマシンとチューリング完全}{
	まず、「チューリング完全である」ということは「プログラミング言語」などの計算を行う体系が「チューリングマシンと同じ能力をもつ」ということである。
	従って、チューリング完全について詳しく説明を行う前にチューリングマシンについての説明を行う。\\
			
	\section{チューリングマシンとは}{
		チューリングマシンとは、{\bf アラン・マティソン・チューリング}\footnote{イギリスの数学者}が1936年に発表した論文「計算可能数についての決定問題への対応」\footnote{On Computable Numbers, with an application to the. Entscheidungsproblem}に書かれる仮想機械(計算機模型)のことである。\\
		チューリングマシンとは、すなわち、計算機を数学的に検証/議論する上で必要となる、理想化/単純化された仮想的な計算機である。
		この理論では、チューリングマシンは{\bf 無限に長いテープと、そのテープに情報を読み書きするヘッドから構成され、以下に示す基本操作を内部状態が停止状態になるまで反復して実行し続ける機械}として想定された。\\
		チューリングマシンの基本操作は以下の3つであり、これを繰り返す。\\
		\begin{itemize}
			\item ヘッド一のテープに情報
			\item 機械の内部状態を帰る
			\item ヘッドを右か左に一つ移動する
		\end{itemize}
	}
}
